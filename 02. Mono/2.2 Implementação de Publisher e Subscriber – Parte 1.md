
---

# Cap√≠tulo 2: Mono
## 2.2 Implementa√ß√£o de Publisher e Subscriber ‚Äì Parte 1

Nesta etapa do aprendizado, vamos criar manualmente nossas pr√≥prias implementa√ß√µes de um **Publisher**, um **Subscriber** e uma **Subscription**, seguindo a especifica√ß√£o **Reactive Streams**.

Embora na pr√°tica utilizemos bibliotecas como o Project Reactor, entender como essas interfaces funcionam internamente ajuda a **construir uma base s√≥lida**, especialmente para compreender conceitos como `request(n)` e `cancel()`.

---

## üß© Implementa√ß√£o do Subscriber

O `SubscriberImpl` √© respons√°vel por consumir os dados enviados pelo `Publisher`. Ele implementa a interface `Subscriber<String>`, ou seja, trabalha com fluxos de dados do tipo `String`.

### Classe `SubscriberImpl`

```java
package com.francisco.sec01.subscriber;

import org.reactivestreams.Subscriber;
import org.reactivestreams.Subscription;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class SubscriberImpl implements Subscriber<String> {

    private static final Logger log = LoggerFactory.getLogger(SubscriberImpl.class);
    private Subscription subscription;

    public Subscription getSubscription() {
        return subscription;
    }

    @Override
    public void onSubscribe(Subscription subscription) {
        this.subscription = subscription;
    }

    @Override
    public void onNext(String email) {
        log.info("received: {}", email);
    }

    @Override
    public void onError(Throwable throwable) {
        log.error("error", throwable);
    }

    @Override
    public void onComplete() {
        log.info("completed");
    }

}
```

> üìå Observa√ß√£o: o m√©todo `getSubscription()` permite acessar a refer√™ncia da `Subscription` fora da classe, √∫til para testes ou demonstra√ß√µes posteriores.

---

## üß© Implementa√ß√£o do Publisher

A classe `PublisherImpl` √© respons√°vel por receber um subscriber e entregar a ele uma inst√¢ncia da `Subscription`.

### Classe `PublisherImpl`

```java
package com.francisco.sec01.publisher;

import org.reactivestreams.Publisher;
import org.reactivestreams.Subscriber;

public class PublisherImpl implements Publisher<String> {

    @Override
    public void subscribe(Subscriber<? super String> subscriber) {
        var subscription = new SubscriptionImpl(subscriber);
        subscriber.onSubscribe(subscription);
    }

}
```

> üìå Neste ponto, o `PublisherImpl` apenas cria a `SubscriptionImpl` e a entrega ao `Subscriber`. Ainda n√£o h√° l√≥gica de envio de dados ‚Äî isso ser√° trabalhado mais adiante.

---

## üß© Implementa√ß√£o da Subscription

A `SubscriptionImpl` √© o elo entre o `Publisher` e o `Subscriber`. Ela deve controlar a l√≥gica de emiss√£o de dados (`request`) e encerramento de fluxo (`cancel`), mesmo que ainda estejam vazias nesta fase.

### Classe `SubscriptionImpl`

```java
package com.francisco.sec01.publisher;

import org.reactivestreams.Subscriber;
import org.reactivestreams.Subscription;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class SubscriptionImpl implements Subscription {

    private static final Logger log = LoggerFactory.getLogger(SubscriptionImpl.class);
    private Subscriber<? super String> subscriber;

    public SubscriptionImpl(Subscriber<? super String> subscriber) {
        this.subscriber = subscriber;
    }

    @Override
    public void request(long l) {
        // Implementa√ß√£o futura
    }

    @Override
    public void cancel() {
        // Implementa√ß√£o futura
    }

}
```

---

## ‚úÖ O que foi feito at√© aqui

- Criamos um **Subscriber personalizado** que implementa `onNext`, `onError` e `onComplete`.
- Implementamos um **Publisher simples**, respons√°vel por iniciar o fluxo conectando o subscriber √† subscription.
- Come√ßamos a montar uma **Subscription**, que mais adiante controlar√° a l√≥gica de emiss√£o dos dados.

---
