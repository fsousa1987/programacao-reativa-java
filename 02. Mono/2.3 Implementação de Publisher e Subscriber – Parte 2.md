
---

# Cap√≠tulo 2: Mono
## 2.3 Implementa√ß√£o de Publisher e Subscriber ‚Äì Parte 2

Com a base estrutural das interfaces `Publisher`, `Subscriber` e `Subscription` j√° estabelecida, neste cap√≠tulo vamos **implementar a l√≥gica de emiss√£o controlada de dados** dentro do m√©todo `request(long n)`, simulando um fluxo reativo com controle de cancelamento e limita√ß√£o de itens emitidos.

Essa abordagem nos permitir√° observar na pr√°tica como o modelo Publisher/Subscriber trata **solicita√ß√µes sob demanda** e **finaliza√ß√£o do fluxo**.

---

## üß† Comportamento esperado da Subscription

- O m√©todo `request(long n)` ser√° respons√°vel por emitir at√© `n` itens para o subscriber.
- O fluxo **ser√° encerrado automaticamente** quando for atingido um n√∫mero m√°ximo de elementos (definido como 10).
- Caso o subscriber cancele a assinatura, nenhuma nova emiss√£o ser√° feita.
- Os dados emitidos ser√£o **e-mails aleat√≥rios**, gerados com a biblioteca **Java Faker**.

---

## üß© Implementa√ß√£o atualizada da `SubscriptionImpl`

```java
package com.francisco.sec01.publisher;

import com.github.javafaker.Faker;
import org.reactivestreams.Subscriber;
import org.reactivestreams.Subscription;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class SubscriptionImpl implements Subscription {

    private static final Logger log = LoggerFactory.getLogger(SubscriptionImpl.class);
    private static final int MAX_ITEMS = 10;

    private final Subscriber<? super String> subscriber;
    private final Faker faker = Faker.instance();

    private int count = 0;
    private boolean isCancelled;

    public SubscriptionImpl(Subscriber<? super String> subscriber) {
        this.subscriber = subscriber;
    }

    @Override
    public void request(long requested) {
        if (isCancelled) return;

        log.info("subscriber has requested {} items", requested);

        for (int i = 0; i < requested && count < MAX_ITEMS; i++) {
            String email = faker.internet().emailAddress();
            subscriber.onNext(email);
            count++;
        }

        if (count == MAX_ITEMS) {
            log.info("no more data to produce");
            subscriber.onComplete();
            isCancelled = true;
        }
    }

    @Override
    public void cancel() {
        isCancelled = true;
        log.info("subscriber has cancelled");
    }
}
```

---

## üîç Explica√ß√µes importantes

- A vari√°vel `count` controla quantos itens j√° foram emitidos no total.
- O valor `MAX_ITEMS` simula um limite de registros dispon√≠veis (por exemplo, linhas de uma tabela).
- O m√©todo `cancel()` apenas define a flag `isCancelled`, impedindo futuras emiss√µes.
- Ap√≥s a emiss√£o total dos itens, o m√©todo `onComplete()` √© invocado, sinalizando o encerramento do fluxo.

---

## ‚úÖ O que foi adicionado

- Implementa√ß√£o real do m√©todo `request()`, com uso de `for` e verifica√ß√£o dupla:
    - Quantidade solicitada (`requested`)
    - Quantidade m√°xima (`MAX_ITEMS`)
- Emiss√£o de e-mails aleat√≥rios com a biblioteca `Faker`.
- Finaliza√ß√£o do fluxo com `onComplete()` quando todos os dados forem emitidos.
- Suporte ao cancelamento via flag booleana.

---
