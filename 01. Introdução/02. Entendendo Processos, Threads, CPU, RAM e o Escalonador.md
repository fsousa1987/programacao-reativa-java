
---

# Cap√≠tulo 2: Entendendo Processos, Threads, CPU, RAM e o Escalonador

Para compreendermos a programa√ß√£o reativa de forma s√≥lida, √© essencial dominarmos alguns conceitos fundamentais sobre como os programas s√£o executados no computador. Neste cap√≠tulo, vamos entender como **processos, threads, mem√≥ria RAM, CPU e o escalonador do sistema operacional** trabalham em conjunto.

## Do JAR ao Processo

Imagine que voc√™ desenvolveu uma aplica√ß√£o Java simples e a empacotou em um arquivo `.jar`. Esse arquivo estar√° armazenado em algum lugar do disco r√≠gido do seu computador.

Ao executar o comando:

```bash
java -jar minha-aplicacao.jar
```

a JVM (Java Virtual Machine) √© inicializada, o conte√∫do do `.jar` √© carregado na mem√≥ria e um **processo** √© criado.

Um **processo** nada mais √© do que uma inst√¢ncia de um programa em execu√ß√£o. Ele possui seu **pr√≥prio espa√ßo de mem√≥ria isolado** e inclui elementos como o c√≥digo da aplica√ß√£o, dados e outros recursos alocados pelo sistema operacional ‚Äî por exemplo, mem√≥ria, conex√µes de rede (sockets), arquivos e por a√≠ vai.

> üí° **Nota**: A cria√ß√£o e destrui√ß√£o de processos √© uma opera√ß√£o considerada **pesada**, pois consome bastante tempo e recursos do sistema operacional.

Contudo, apenas o processo existir n√£o significa que ele esteja sendo executado ativamente. A **CPU (Unidade Central de Processamento)** √© quem de fato executa as instru√ß√µes do programa. O processo, por si s√≥, apenas est√° dispon√≠vel na mem√≥ria aguardando para ser processado.

## Threads: Unidades de Execu√ß√£o

Um processo pode conter uma ou v√°rias **threads**. Toda thread est√° vinculada a um processo, e **ao menos uma thread sempre existir√° em qualquer processo em execu√ß√£o**.

Uma **thread** √© a menor unidade de execu√ß√£o dentro de um processo. Enquanto o processo representa uma unidade de **recursos**, a thread representa uma unidade de **execu√ß√£o**.

M√∫ltiplas threads dentro de um mesmo processo compartilham o espa√ßo de mem√≥ria atribu√≠do a esse processo. Por exemplo, em sua m√°quina, se voc√™ abrir o monitor de atividades (ou gerenciador de tarefas), ver√° que:

- O navegador Chrome pode estar usando 40+ threads.
- O IntelliJ IDEA pode estar usando 50+ threads.
- Um editor de texto simples como o Sublime Text pode usar cerca de 20 threads.

Cada uma dessas aplica√ß√µes √© um processo distinto com diversas threads competindo pela CPU.

## Escalonamento: como as threads s√£o executadas

Para coordenar a execu√ß√£o das threads, o sistema operacional utiliza um componente chamado **escalonador (scheduler)**. Sua fun√ß√£o √© **decidir qual thread ser√° executada, por quanto tempo, e em qual n√∫cleo da CPU**.

Em sistemas com apenas **um √∫nico n√∫cleo de CPU**, mesmo que existam m√∫ltiplas threads, elas n√£o s√£o executadas simultaneamente. O escalonador alterna entre elas ‚Äî um processo conhecido como **troca de contexto (context switch)**.

> üîÅ Quando ocorre uma troca de contexto, o sistema precisa **salvar o estado da thread atual**, incluindo sua posi√ß√£o de execu√ß√£o e vari√°veis locais, para poder retom√°-la exatamente do ponto onde parou no futuro.

Se seu computador possui m√∫ltiplos n√∫cleos de CPU (como √© comum hoje em dia), o sistema pode **executar m√∫ltiplas threads ao mesmo tempo**, uma em cada n√∫cleo.

> üí° **Terminologia**: Muitas vezes usamos os termos ‚ÄúCPU‚Äù e ‚Äúprocessador‚Äù de forma intercambi√°vel. Em sistemas modernos, uma CPU geralmente possui **v√°rios n√∫cleos (cores)**, e cada n√∫cleo funciona como um processador independente.

## Mem√≥ria: Heap e Stack

Durante a execu√ß√£o, as threads precisam de mem√≥ria para armazenar dados tempor√°rios e objetos. A JVM divide essa mem√≥ria principalmente em dois espa√ßos:

- **Heap memory (mem√≥ria heap)**: onde s√£o alocados objetos din√¢micos ‚Äî como `ArrayList`, `HashMap`, entre outros ‚Äî durante a execu√ß√£o da aplica√ß√£o.
- **Stack memory (mem√≥ria de pilha)**: onde s√£o armazenadas as **vari√°veis locais** e **informa√ß√µes das chamadas de m√©todos** feitas por uma thread.

Cada thread possui sua **pr√≥pria stack memory**, isolada das outras threads. Isso permite que cada uma tenha seu pr√≥prio fluxo de execu√ß√£o independente.

O **tamanho da stack memory** de uma thread √© definido no momento da cria√ß√£o da thread e **n√£o pode ser alterado depois**. Por padr√£o, a JVM atribui **1 MB por thread**, mas isso pode variar com base no sistema operacional e na arquitetura do processador. Por exemplo, em um sistema macOS, esse valor padr√£o pode ser de 2 MB.

Mesmo que uma thread esteja inativa (n√£o executando nenhuma tarefa), o sistema ainda reserva mem√≥ria para sua pilha.

## O Custo das Threads

Embora threads nos ajudem a aproveitar melhor os recursos da CPU, elas tamb√©m **custam caro** ‚Äî especialmente em sistemas com muitas opera√ß√µes de rede.

Por exemplo, em uma arquitetura de microsservi√ßos, √© comum que a aplica√ß√£o precise realizar **diversas chamadas de rede**, como buscar dados de outro servi√ßo ou acessar um banco remoto. Essas chamadas costumam ser **lentas**, e durante esse tempo, a thread que fez a chamada fica **ociosa**, aguardando uma resposta.

Isso significa que, mesmo que a CPU esteja dispon√≠vel, ela pode n√£o estar sendo usada eficientemente. Para contornar esse problema, muitos desenvolvedores tentam criar um n√∫mero elevado de threads ‚Äî mas isso √© problem√°tico, pois:

- **Cada thread consome mem√≥ria**, especialmente para sua stack.
- A cria√ß√£o e destrui√ß√£o de threads tamb√©m envolve custo computacional.
- O n√∫mero de threads que um sistema pode suportar √© limitado.

Portanto, **threads s√£o recursos limitados e pesados**, e us√°-las em excesso pode resultar em um sistema ineficiente e propenso a falhas sob carga.

---

Neste cap√≠tulo, vimos como a infraestrutura de execu√ß√£o de um programa funciona por tr√°s das cortinas. Compreender bem os pap√©is de **processo, thread, CPU, mem√≥ria e escalonador** √© essencial para dar os pr√≥ximos passos no estudo da programa√ß√£o reativa, que visa justamente **utilizar esses recursos de forma mais eficiente**.

---
