
---

# Cap√≠tulo 7: Comunica√ß√£o entre Publisher e Subscriber ‚Äî Passo a Passo

Agora que entendemos os fundamentos da programa√ß√£o reativa e sua base no padr√£o Observer, √© hora de vermos **na pr√°tica como funciona o ciclo de comunica√ß√£o** entre um **Publisher** e um **Subscriber**, conforme definido pela **Reactive Streams Specification**.

> ‚ö†Ô∏è Este cap√≠tulo √© extremamente importante. Se necess√°rio, releia-o quantas vezes for preciso para garantir que os conceitos estejam totalmente claros.

Vamos detalhar esse fluxo **passo a passo**.

---

## Passo 1 ‚Äì Conex√£o: `Publisher.subscribe(Subscriber)`

Tudo come√ßa com dois componentes:

- Um **Publisher**, que emite dados.
- Um **Subscriber**, que deseja receber esses dados.

Para estabelecer a conex√£o, o **Publisher** exp√µe um m√©todo chamado `subscribe()`, que recebe como argumento a inst√¢ncia do **Subscriber**.

```java
publisher.subscribe(subscriber);
```

Ao fazer isso, o **Subscriber se inscreve para receber dados do Publisher**.

---

## Passo 2 ‚Äì Entrega do Subscription

Assim que a inscri√ß√£o √© aceita, o Publisher envia ao Subscriber um **objeto de controle** chamado `Subscription`. Isso √© feito invocando o m√©todo `onSubscribe(Subscription)` definido na interface do `Subscriber`.

```java
subscriber.onSubscribe(subscription);
```

Esse objeto `Subscription` ser√° usado pelo Subscriber para controlar a comunica√ß√£o ‚Äî como **solicitar dados** ou **cancelar a inscri√ß√£o**.

---

## Passo 3 ‚Äì Relacionamento Estabelecido

A partir desse momento, o v√≠nculo est√° estabelecido. O Subscriber pode interagir com o Publisher atrav√©s do objeto `Subscription`.

As a√ß√µes poss√≠veis s√£o:

- `subscription.request(n)` ‚Üí solicita **n** itens.
- `subscription.cancel()` ‚Üí encerra o relacionamento, recusando novos dados.

---

## Passo 4 ‚Äì Emiss√£o de Itens: `onNext()`

Quando o Subscriber chama `request(n)`, o Publisher responde enviando **at√© n itens** utilizando o m√©todo `onNext()` da interface do Subscriber:

```java
subscriber.onNext(item);
```

Isso ocorre de forma **sequencial**.  
Se, por exemplo, o Subscriber solicitou 3 itens:

- O Publisher pode enviar at√© 3 itens com chamadas a `onNext(item)`.
- Ele **nunca deve enviar mais do que o solicitado**.

> üö´ Enviar mais itens do que os solicitados **viola a especifica√ß√£o** Reactive Streams.

O Subscriber pode solicitar mais itens a qualquer momento, repetindo a chamada a `request(n)`.

---

## Passo 5 ‚Äì Finaliza√ß√£o: `onComplete()`

Quando o Publisher **n√£o tem mais itens para enviar**, ele invoca o m√©todo `onComplete()` no Subscriber:

```java
subscriber.onComplete();
```

A partir desse ponto:

- O Publisher n√£o enviar√° mais nenhum dado.
- O objeto `Subscription` **se torna inv√°lido** ‚Äî n√£o √© mais poss√≠vel solicitar dados.

---

## Passo 6 ‚Äì Erro: `onError(Throwable)`

Caso ocorra algum problema durante o processamento dos dados, o Publisher pode notificar o Subscriber usando:

```java
subscriber.onError(throwable);
```

Assim como no `onComplete()`, **ap√≥s o `onError()` a comunica√ß√£o √© encerrada** e a `Subscription` perde a validade.

> ‚öñÔ∏è **Importante**: o `onComplete()` e o `onError()` s√£o **mutuamente exclusivos**. Apenas **um deles ser√° chamado**, e **somente uma vez**.

---

## Resumo do Ciclo

```plaintext
Publisher ‚Üí subscribe(subscriber)
          ‚Üí onSubscribe(subscription)
Subscriber ‚Üí request(n)
Publisher ‚Üí onNext(item)... (at√© n vezes)
          ‚Üí onComplete() ou onError()
```

---

## Frequ√™ncia dos M√©todos

| M√©todo          | Pode ser chamado...                             |
|----------------|--------------------------------------------------|
| `onSubscribe()` | **1 vez**                                        |
| `onNext()`      | **0 ou mais vezes** (at√© o n√∫mero solicitado)    |
| `onComplete()`  | **1 vez no m√°ximo**, e s√≥ se n√£o ocorrer erro    |
| `onError()`     | **1 vez no m√°ximo**, se ocorrer algum erro       |

---

## Terminologias Equivalentes

No mundo da programa√ß√£o reativa, os termos podem variar. √â importante reconhec√™-los:

| Termo Principal | Termos Equivalentes                             |
|-----------------|-------------------------------------------------|
| `Publisher`     | source, observable, producer, upstream          |
| `Subscriber`    | sink, observer, consumer, downstream            |
| `Processor`     | operator                                        |

---

## Modelando a Comunica√ß√£o com Publisher e Subscriber

Em **programa√ß√£o orientada a objetos**, modelamos tudo como **classes** e **objetos**:  
Ex.: `Cliente`, `Cart√£oDeCr√©dito`, `Carro` ‚Äî todos s√£o entidades modeladas por classes.

Na **programa√ß√£o reativa**, o foco est√° no **fluxo de dados entre componentes**, e modelamos essa comunica√ß√£o com **Publisher e Subscriber**.

### Exemplos pr√°ticos:

üîπ Uma aplica√ß√£o React (frontend) que consome uma API REST pode ser modelada assim:
- Backend ‚Üí `Publisher` (fornece os dados)
- Frontend ‚Üí `Subscriber` (recebe os dados)

üîπ Em uma arquitetura de microsservi√ßos:
- Um servi√ßo depende de outro?
    - Servi√ßo A ‚Üí `Publisher`
    - Servi√ßo B ‚Üí `Subscriber`

üîπ Dentro de uma pr√≥pria classe:
- Um m√©todo depende de outro?
    - M√©todo A ‚Üí `Publisher`
    - M√©todo B ‚Üí `Subscriber`

> üìå Regra pr√°tica:  
> Qualquer componente que **emite dados** atua como **Publisher**.  
> Qualquer componente que **consome dados** atua como **Subscriber**.

---

## Conclus√£o

O ciclo Publisher/Subscriber √© o **n√∫cleo da programa√ß√£o reativa**.  
Entender **como eles interagem**, **como o controle √© feito via Subscription** e **como erros e finaliza√ß√µes s√£o tratados** √© essencial para escrever c√≥digo robusto, eficiente e aderente √† especifica√ß√£o Reactive Streams.

---
